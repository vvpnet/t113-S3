From 7c07cc5f5ec82bfcf365c6616f1836c32529c26d Mon Sep 17 00:00:00 2001
From: John Watts <contact@jookia.org>
Date: Wed, 13 Mar 2024 06:17:18 +1100
Subject: [PATCH] Variable clocking CS5368

---
 drivers/clk/sunxi-ng/ccu-sun20i-d1.c   |  23 +-
 drivers/clk/sunxi-ng/ccu-sun4i-a10.c   |   8 +-
 drivers/clk/sunxi-ng/ccu-sun50i-a100.c |  17 +-
 drivers/clk/sunxi-ng/ccu-sun50i-a64.c  |   7 +-
 drivers/clk/sunxi-ng/ccu-sun50i-h6.c   |   9 +-
 drivers/clk/sunxi-ng/ccu-sun5i.c       |   9 +-
 drivers/clk/sunxi-ng/ccu-sun6i-a31.c   |   7 +-
 drivers/clk/sunxi-ng/ccu-sun8i-a23.c   |   7 +-
 drivers/clk/sunxi-ng/ccu-sun8i-a33.c   |   7 +-
 drivers/clk/sunxi-ng/ccu-sun8i-a83t.c  |  10 +-
 drivers/clk/sunxi-ng/ccu-sun8i-h3.c    |   7 +-
 drivers/clk/sunxi-ng/ccu-sun8i-r40.c   |   7 +-
 drivers/clk/sunxi-ng/ccu-sun8i-v3s.c   |   7 +-
 drivers/clk/sunxi-ng/ccu_common.h      |   6 +
 drivers/clk/sunxi-ng/ccu_nm.c          |  57 ++--
 drivers/clk/sunxi-ng/ccu_nm.h          |   6 +-
 drivers/clk/sunxi-ng/ccu_sdm.c         | 224 +++++++-------
 drivers/clk/sunxi-ng/ccu_sdm.h         |  56 +---
 sound/soc/codecs/Kconfig               |   6 +
 sound/soc/codecs/Makefile              |   2 +
 sound/soc/codecs/cs5368.c              | 407 +++++++++++++++++++++++++
 sound/soc/sunxi/sun4i-i2s.c            | 144 ++-------
 22 files changed, 613 insertions(+), 420 deletions(-)
 create mode 100644 sound/soc/codecs/cs5368.c

diff --git a/drivers/clk/sunxi-ng/ccu-sun20i-d1.c b/drivers/clk/sunxi-ng/ccu-sun20i-d1.c
index 48a8fb2c43b7..4820610b5169 100644
--- a/drivers/clk/sunxi-ng/ccu-sun20i-d1.c
+++ b/drivers/clk/sunxi-ng/ccu-sun20i-d1.c
@@ -168,17 +168,12 @@ static struct ccu_nkmp pll_ve_clk = {
  * The M factor must be an even number to produce a 50% duty cycle output.
  */
 #define SUN20I_D1_PLL_AUDIO0_REG		0x078
-static struct ccu_sdm_setting pll_audio0_sdm_table[] = {
-	{ .rate = 90316800, .pattern = 0xc001288d, .m = 6, .n = 22 },
-};
-
 static struct ccu_nm pll_audio0_4x_clk = {
 	.enable		= BIT(27),
 	.lock		= BIT(28),
-	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.n		= _SUNXI_CCU_MULT_OFFSET_MIN_MAX(8, 8, 1, 12, 125),
 	.m		= _SUNXI_CCU_DIV(16, 6),
-	.sdm		= _SUNXI_CCU_SDM(pll_audio0_sdm_table, BIT(24),
-					 0x178, BIT(31)),
+	.sdm		= _SUNXI_CCU_SDM(BIT(24), 0x178, BIT(31)),
 	.min_rate	= 180000000U,
 	.max_rate	= 3000000000U,
 	.common		= {
@@ -194,9 +189,9 @@ static const struct clk_hw *pll_audio0_4x_hws[] = {
 	&pll_audio0_4x_clk.common.hw
 };
 static CLK_FIXED_FACTOR_HWS(pll_audio0_2x_clk, "pll-audio0-2x",
-			    pll_audio0_4x_hws, 2, 1, 0);
+			    pll_audio0_4x_hws, 2, 1, CLK_SET_RATE_PARENT);
 static CLK_FIXED_FACTOR_HWS(pll_audio0_clk, "pll-audio0",
-			    pll_audio0_4x_hws, 4, 1, 0);
+			    pll_audio0_4x_hws, 4, 1, CLK_SET_RATE_PARENT);
 
 /*
  * PLL_AUDIO1 doesn't need Fractional-N. The output is usually 614.4 MHz for
@@ -206,12 +201,14 @@ static CLK_FIXED_FACTOR_HWS(pll_audio0_clk, "pll-audio0",
 static struct ccu_nm pll_audio1_clk = {
 	.enable		= BIT(27),
 	.lock		= BIT(28),
-	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.n		= _SUNXI_CCU_MULT_OFFSET_MIN_MAX(8, 8, 1, 12, 125),
 	.m		= _SUNXI_CCU_DIV(1, 1),
+	.sdm		= _SUNXI_CCU_SDM(BIT(24), 0x180, BIT(31)),
 	.min_rate	= 180000000U,
 	.max_rate	= 3000000000U,
 	.common		= {
 		.reg		= 0x080,
+		.features	= CCU_FEATURE_SIGMA_DELTA_MOD,
 		.hw.init	= CLK_HW_INIT_PARENTS_DATA("pll-audio1", osc24M,
 							   &ccu_nm_ops,
 							   CLK_SET_RATE_UNGATE),
@@ -222,9 +219,9 @@ static const struct clk_hw *pll_audio1_hws[] = {
 	&pll_audio1_clk.common.hw
 };
 static SUNXI_CCU_M_HWS(pll_audio1_div2_clk, "pll-audio1-div2",
-		       pll_audio1_hws, 0x080, 16, 3, 0);
+		       pll_audio1_hws, 0x080, 16, 3, CLK_SET_RATE_PARENT);
 static SUNXI_CCU_M_HWS(pll_audio1_div5_clk, "pll-audio1-div5",
-		       pll_audio1_hws, 0x080, 20, 3, 0);
+		       pll_audio1_hws, 0x080, 20, 3, CLK_SET_RATE_PARENT);
 
 /*
  * The CPUX gate is not modelled - it is in a separate register (0x504)
@@ -551,7 +548,7 @@ static SUNXI_CCU_MP_HW_WITH_MUX_GATE(i2s2_clk, "i2s2", i2s_spdif_tx_parents, 0xa
 				     8, 2,	/* P */
 				     24, 3,	/* mux */
 				     BIT(31),	/* gate */
-				     0);
+				     CLK_SET_RATE_PARENT);
 
 static const struct clk_hw *i2s2_asrc_parents[] = {
 	&pll_audio0_4x_clk.common.hw,
diff --git a/drivers/clk/sunxi-ng/ccu-sun4i-a10.c b/drivers/clk/sunxi-ng/ccu-sun4i-a10.c
index 451ebb7c99a3..fa2fe28d2f4a 100644
--- a/drivers/clk/sunxi-ng/ccu-sun4i-a10.c
+++ b/drivers/clk/sunxi-ng/ccu-sun4i-a10.c
@@ -56,17 +56,11 @@ static struct ccu_nkmp pll_core_clk = {
  */
 #define SUN4I_PLL_AUDIO_REG	0x008
 
-static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 22579200, .pattern = 0xc0010d84, .m = 8, .n = 7 },
-	{ .rate = 24576000, .pattern = 0xc000ac02, .m = 14, .n = 14 },
-};
-
 static struct ccu_nm pll_audio_base_clk = {
 	.enable		= BIT(31),
 	.n		= _SUNXI_CCU_MULT_OFFSET(8, 7, 0),
 	.m		= _SUNXI_CCU_DIV_OFFSET(0, 5, 0),
-	.sdm		= _SUNXI_CCU_SDM(pll_audio_sdm_table, 0,
-					 0x00c, BIT(31)),
+	.sdm		= _SUNXI_CCU_SDM(0, 0x00c, BIT(31)),
 	.common		= {
 		.reg		= 0x008,
 		.features	= CCU_FEATURE_SIGMA_DELTA_MOD,
diff --git a/drivers/clk/sunxi-ng/ccu-sun50i-a100.c b/drivers/clk/sunxi-ng/ccu-sun50i-a100.c
index 5f93b5526e13..4d74949d20dd 100644
--- a/drivers/clk/sunxi-ng/ccu-sun50i-a100.c
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-a100.c
@@ -193,17 +193,12 @@ static struct ccu_nkmp pll_ve_clk = {
  * ignore it for now.
  */
 #define SUN50I_A100_PLL_COM_REG		0x060
-static struct ccu_sdm_setting pll_com_sdm_table[] = {
-	{ .rate = 451584000, .pattern = 0xc0014396, .m = 2, .n = 37 },
-};
-
 static struct ccu_nm pll_com_clk = {
 	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
 	.lock		= SUN50I_A100_PLL_LOCK,
 	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
 	.m		= _SUNXI_CCU_DIV(0, 1),
-	.sdm		= _SUNXI_CCU_SDM(pll_com_sdm_table, BIT(24),
-					 0x160, BIT(31)),
+	.sdm		= _SUNXI_CCU_SDM(BIT(24), 0x160, BIT(31)),
 	.common		= {
 		.reg		= 0x060,
 		.features	= CCU_FEATURE_SIGMA_DELTA_MOD,
@@ -236,21 +231,13 @@ static struct ccu_nm pll_video3_clk = {
  * Enforce the default for them, which is m0 = 1, m1 = 0.
  */
 #define SUN50I_A100_PLL_AUDIO_REG		0x078
-static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 45158400, .pattern = 0xc001bcd3, .m = 18, .n = 33 },
-	{ .rate = 49152000, .pattern = 0xc001eb85, .m = 20, .n = 40 },
-	{ .rate = 180633600, .pattern = 0xc001288d, .m = 3, .n = 22 },
-	{ .rate = 196608000, .pattern = 0xc001eb85, .m = 5, .n = 40 },
-};
-
 static struct ccu_nm pll_audio_clk = {
 	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
 	.lock		= SUN50I_A100_PLL_LOCK,
 	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
 	.m		= _SUNXI_CCU_DIV(16, 6),
 	.fixed_post_div	= 2,
-	.sdm		= _SUNXI_CCU_SDM(pll_audio_sdm_table, BIT(24),
-					 0x178, BIT(31)),
+	.sdm		= _SUNXI_CCU_SDM(BIT(24), 0x178, BIT(31)),
 	.common		= {
 		.reg		= 0x078,
 		.features	= CCU_FEATURE_FIXED_POSTDIV |
diff --git a/drivers/clk/sunxi-ng/ccu-sun50i-a64.c b/drivers/clk/sunxi-ng/ccu-sun50i-a64.c
index 8951ffc14ff5..163853ab2e36 100644
--- a/drivers/clk/sunxi-ng/ccu-sun50i-a64.c
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-a64.c
@@ -53,16 +53,11 @@ static struct ccu_nkmp pll_cpux_clk = {
  */
 #define SUN50I_A64_PLL_AUDIO_REG	0x008
 
-static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 22579200, .pattern = 0xc0010d84, .m = 8, .n = 7 },
-	{ .rate = 24576000, .pattern = 0xc000ac02, .m = 14, .n = 14 },
-};
-
 static SUNXI_CCU_NM_WITH_SDM_GATE_LOCK(pll_audio_base_clk, "pll-audio-base",
 				       "osc24M", 0x008,
 				       8, 7,	/* N */
 				       0, 5,	/* M */
-				       pll_audio_sdm_table, BIT(24),
+				       BIT(24),
 				       0x284, BIT(31),
 				       BIT(31),	/* gate */
 				       BIT(28),	/* lock */
diff --git a/drivers/clk/sunxi-ng/ccu-sun50i-h6.c b/drivers/clk/sunxi-ng/ccu-sun50i-h6.c
index 42568c616181..6f3ee776edcc 100644
--- a/drivers/clk/sunxi-ng/ccu-sun50i-h6.c
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-h6.c
@@ -203,19 +203,12 @@ static struct ccu_nkmp pll_hsic_clk = {
  * hardcode it to match with the clock names.
  */
 #define SUN50I_H6_PLL_AUDIO_REG		0x078
-
-static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 541900800, .pattern = 0xc001288d, .m = 1, .n = 22 },
-	{ .rate = 589824000, .pattern = 0xc00126e9, .m = 1, .n = 24 },
-};
-
 static struct ccu_nm pll_audio_base_clk = {
 	.enable		= BIT(31),
 	.lock		= BIT(28),
 	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
 	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
-	.sdm		= _SUNXI_CCU_SDM(pll_audio_sdm_table,
-					 BIT(24), 0x178, BIT(31)),
+	.sdm		= _SUNXI_CCU_SDM(BIT(24), 0x178, BIT(31)),
 	.common		= {
 		.features	= CCU_FEATURE_SIGMA_DELTA_MOD,
 		.reg		= 0x078,
diff --git a/drivers/clk/sunxi-ng/ccu-sun5i.c b/drivers/clk/sunxi-ng/ccu-sun5i.c
index 1f4bc0e773a7..cd48faacfd21 100644
--- a/drivers/clk/sunxi-ng/ccu-sun5i.c
+++ b/drivers/clk/sunxi-ng/ccu-sun5i.c
@@ -51,12 +51,6 @@ static struct ccu_nkmp pll_core_clk = {
  * match the clock names.
  */
 #define SUN5I_PLL_AUDIO_REG	0x008
-
-static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 22579200, .pattern = 0xc0010d84, .m = 8, .n = 7 },
-	{ .rate = 24576000, .pattern = 0xc000ac02, .m = 14, .n = 14 },
-};
-
 static struct ccu_nm pll_audio_base_clk = {
 	.enable		= BIT(31),
 	.n		= _SUNXI_CCU_MULT_OFFSET(8, 7, 0),
@@ -66,8 +60,7 @@ static struct ccu_nm pll_audio_base_clk = {
 	 * offset
 	 */
 	.m		= _SUNXI_CCU_DIV_OFFSET(0, 5, 0),
-	.sdm		= _SUNXI_CCU_SDM(pll_audio_sdm_table, 0,
-					 0x00c, BIT(31)),
+	.sdm		= _SUNXI_CCU_SDM(0, 0x00c, BIT(31)),
 	.common		= {
 		.reg		= 0x008,
 		.features	= CCU_FEATURE_SIGMA_DELTA_MOD,
diff --git a/drivers/clk/sunxi-ng/ccu-sun6i-a31.c b/drivers/clk/sunxi-ng/ccu-sun6i-a31.c
index 0762deffb33c..fecbfe973f87 100644
--- a/drivers/clk/sunxi-ng/ccu-sun6i-a31.c
+++ b/drivers/clk/sunxi-ng/ccu-sun6i-a31.c
@@ -52,16 +52,11 @@ static SUNXI_CCU_NKM_WITH_GATE_LOCK(pll_cpu_clk, "pll-cpu",
  */
 #define SUN6I_A31_PLL_AUDIO_REG	0x008
 
-static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 22579200, .pattern = 0xc0010d84, .m = 8, .n = 7 },
-	{ .rate = 24576000, .pattern = 0xc000ac02, .m = 14, .n = 14 },
-};
-
 static SUNXI_CCU_NM_WITH_SDM_GATE_LOCK(pll_audio_base_clk, "pll-audio-base",
 				       "osc24M", 0x008,
 				       8, 7,	/* N */
 				       0, 5,	/* M */
-				       pll_audio_sdm_table, BIT(24),
+				       BIT(24),
 				       0x284, BIT(31),
 				       BIT(31),	/* gate */
 				       BIT(28),	/* lock */
diff --git a/drivers/clk/sunxi-ng/ccu-sun8i-a23.c b/drivers/clk/sunxi-ng/ccu-sun8i-a23.c
index e80cc3864e44..0cf19999e373 100644
--- a/drivers/clk/sunxi-ng/ccu-sun8i-a23.c
+++ b/drivers/clk/sunxi-ng/ccu-sun8i-a23.c
@@ -56,16 +56,11 @@ static struct ccu_nkmp pll_cpux_clk = {
  */
 #define SUN8I_A23_PLL_AUDIO_REG	0x008
 
-static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 22579200, .pattern = 0xc0010d84, .m = 8, .n = 7 },
-	{ .rate = 24576000, .pattern = 0xc000ac02, .m = 14, .n = 14 },
-};
-
 static SUNXI_CCU_NM_WITH_SDM_GATE_LOCK(pll_audio_base_clk, "pll-audio-base",
 				       "osc24M", 0x008,
 				       8, 7,	/* N */
 				       0, 5,	/* M */
-				       pll_audio_sdm_table, BIT(24),
+				       BIT(24),
 				       0x284, BIT(31),
 				       BIT(31),	/* gate */
 				       BIT(28),	/* lock */
diff --git a/drivers/clk/sunxi-ng/ccu-sun8i-a33.c b/drivers/clk/sunxi-ng/ccu-sun8i-a33.c
index d12878a1ba9e..dc660f4ff4ec 100644
--- a/drivers/clk/sunxi-ng/ccu-sun8i-a33.c
+++ b/drivers/clk/sunxi-ng/ccu-sun8i-a33.c
@@ -54,16 +54,11 @@ static struct ccu_nkmp pll_cpux_clk = {
  */
 #define SUN8I_A33_PLL_AUDIO_REG	0x008
 
-static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 22579200, .pattern = 0xc0010d84, .m = 8, .n = 7 },
-	{ .rate = 24576000, .pattern = 0xc000ac02, .m = 14, .n = 14 },
-};
-
 static SUNXI_CCU_NM_WITH_SDM_GATE_LOCK(pll_audio_base_clk, "pll-audio-base",
 				       "osc24M", 0x008,
 				       8, 7,	/* N */
 				       0, 5,	/* M */
-				       pll_audio_sdm_table, BIT(24),
+				       BIT(24),
 				       0x284, BIT(31),
 				       BIT(31),	/* gate */
 				       BIT(28),	/* lock */
diff --git a/drivers/clk/sunxi-ng/ccu-sun8i-a83t.c b/drivers/clk/sunxi-ng/ccu-sun8i-a83t.c
index 76cbd9e9e89f..72d65475e343 100644
--- a/drivers/clk/sunxi-ng/ccu-sun8i-a83t.c
+++ b/drivers/clk/sunxi-ng/ccu-sun8i-a83t.c
@@ -68,21 +68,13 @@ static struct ccu_mult pll_c1cpux_clk = {
  * which is d1 = 0, d2 = 1.
  */
 #define SUN8I_A83T_PLL_AUDIO_REG	0x008
-
-/* clock rates doubled for post divider */
-static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 45158400, .pattern = 0xc00121ff, .m = 29, .n = 54 },
-	{ .rate = 49152000, .pattern = 0xc000e147, .m = 30, .n = 61 },
-};
-
 static struct ccu_nm pll_audio_clk = {
 	.enable		= BIT(31),
 	.lock		= BIT(2),
 	.n		= _SUNXI_CCU_MULT_OFFSET_MIN_MAX(8, 8, 0, 12, 0),
 	.m		= _SUNXI_CCU_DIV(0, 6),
 	.fixed_post_div	= 2,
-	.sdm		= _SUNXI_CCU_SDM(pll_audio_sdm_table, BIT(24),
-					 0x284, BIT(31)),
+	.sdm		= _SUNXI_CCU_SDM(BIT(24), 0x284, BIT(31)),
 	.common		= {
 		.reg		= SUN8I_A83T_PLL_AUDIO_REG,
 		.lock_reg	= CCU_SUN8I_A83T_LOCK_REG,
diff --git a/drivers/clk/sunxi-ng/ccu-sun8i-h3.c b/drivers/clk/sunxi-ng/ccu-sun8i-h3.c
index 74274c17efb3..a48fa5c2a9b3 100644
--- a/drivers/clk/sunxi-ng/ccu-sun8i-h3.c
+++ b/drivers/clk/sunxi-ng/ccu-sun8i-h3.c
@@ -49,16 +49,11 @@ static SUNXI_CCU_NKMP_WITH_GATE_LOCK(pll_cpux_clk, "pll-cpux",
  */
 #define SUN8I_H3_PLL_AUDIO_REG	0x008
 
-static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 22579200, .pattern = 0xc0010d84, .m = 8, .n = 7 },
-	{ .rate = 24576000, .pattern = 0xc000ac02, .m = 14, .n = 14 },
-};
-
 static SUNXI_CCU_NM_WITH_SDM_GATE_LOCK(pll_audio_base_clk, "pll-audio-base",
 				       "osc24M", 0x008,
 				       8, 7,	/* N */
 				       0, 5,	/* M */
-				       pll_audio_sdm_table, BIT(24),
+				       BIT(24),
 				       0x284, BIT(31),
 				       BIT(31),	/* gate */
 				       BIT(28),	/* lock */
diff --git a/drivers/clk/sunxi-ng/ccu-sun8i-r40.c b/drivers/clk/sunxi-ng/ccu-sun8i-r40.c
index 31eca0d3bc1e..f8020ea8ca41 100644
--- a/drivers/clk/sunxi-ng/ccu-sun8i-r40.c
+++ b/drivers/clk/sunxi-ng/ccu-sun8i-r40.c
@@ -55,16 +55,11 @@ static struct ccu_nkmp pll_cpu_clk = {
  */
 #define SUN8I_R40_PLL_AUDIO_REG	0x008
 
-static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 22579200, .pattern = 0xc0010d84, .m = 8, .n = 7 },
-	{ .rate = 24576000, .pattern = 0xc000ac02, .m = 14, .n = 14 },
-};
-
 static SUNXI_CCU_NM_WITH_SDM_GATE_LOCK(pll_audio_base_clk, "pll-audio-base",
 				       "osc24M", 0x008,
 				       8, 7,	/* N */
 				       0, 5,	/* M */
-				       pll_audio_sdm_table, BIT(24),
+				       BIT(24),
 				       0x284, BIT(31),
 				       BIT(31),	/* gate */
 				       BIT(28),	/* lock */
diff --git a/drivers/clk/sunxi-ng/ccu-sun8i-v3s.c b/drivers/clk/sunxi-ng/ccu-sun8i-v3s.c
index f3ce8664b288..249d41115676 100644
--- a/drivers/clk/sunxi-ng/ccu-sun8i-v3s.c
+++ b/drivers/clk/sunxi-ng/ccu-sun8i-v3s.c
@@ -51,16 +51,11 @@ static SUNXI_CCU_NKMP_WITH_GATE_LOCK(pll_cpu_clk, "pll-cpu",
  */
 #define SUN8I_V3S_PLL_AUDIO_REG	0x008
 
-static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 22579200, .pattern = 0xc0010d84, .m = 8, .n = 7 },
-	{ .rate = 24576000, .pattern = 0xc000ac02, .m = 14, .n = 14 },
-};
-
 static SUNXI_CCU_NM_WITH_SDM_GATE_LOCK(pll_audio_base_clk, "pll-audio-base",
 				       "osc24M", 0x008,
 				       8, 7,	/* N */
 				       0, 5,	/* M */
-				       pll_audio_sdm_table, BIT(24),
+				       BIT(24),
 				       0x284, BIT(31),
 				       BIT(31),	/* gate */
 				       BIT(28),	/* lock */
diff --git a/drivers/clk/sunxi-ng/ccu_common.h b/drivers/clk/sunxi-ng/ccu_common.h
index 942a72c09437..4cd611643ca4 100644
--- a/drivers/clk/sunxi-ng/ccu_common.h
+++ b/drivers/clk/sunxi-ng/ccu_common.h
@@ -75,4 +75,10 @@ int devm_sunxi_ccu_probe(struct device *dev, void __iomem *reg,
 void of_sunxi_ccu_probe(struct device_node *node, void __iomem *reg,
 			const struct sunxi_ccu_desc *desc);
 
+struct ccu_nm_params {
+	unsigned long	n, min_n, max_n;
+	unsigned long	m, min_m, max_m;
+	unsigned long	min_rate, max_rate;
+};
+
 #endif /* _COMMON_H_ */
diff --git a/drivers/clk/sunxi-ng/ccu_nm.c b/drivers/clk/sunxi-ng/ccu_nm.c
index ffac3deb89d6..5fb6455e8487 100644
--- a/drivers/clk/sunxi-ng/ccu_nm.c
+++ b/drivers/clk/sunxi-ng/ccu_nm.c
@@ -11,11 +11,6 @@
 #include "ccu_gate.h"
 #include "ccu_nm.h"
 
-struct _ccu_nm {
-	unsigned long	n, min_n, max_n;
-	unsigned long	m, min_m, max_m;
-};
-
 static unsigned long ccu_nm_calc_rate(unsigned long parent,
 				      unsigned long n, unsigned long m)
 {
@@ -28,7 +23,7 @@ static unsigned long ccu_nm_calc_rate(unsigned long parent,
 }
 
 static unsigned long ccu_nm_find_best(struct ccu_common *common, unsigned long parent,
-				      unsigned long rate, struct _ccu_nm *nm)
+				      unsigned long rate, struct ccu_nm_params *nm)
 {
 	unsigned long best_rate = 0;
 	unsigned long best_n = 0, best_m = 0;
@@ -105,8 +100,8 @@ static unsigned long ccu_nm_recalc_rate(struct clk_hw *hw,
 	if (!m)
 		m++;
 
-	if (ccu_sdm_helper_is_enabled(&nm->common, &nm->sdm))
-		rate = ccu_sdm_helper_read_rate(&nm->common, &nm->sdm, m, n);
+	if (nm->common.features & CCU_FEATURE_SIGMA_DELTA_MOD)
+		rate = ccu_sdm_helper_calc_rate(&nm->common, &nm->sdm, parent_rate, m, n);
 	else
 		rate = ccu_nm_calc_rate(parent_rate, n, m);
 
@@ -120,7 +115,7 @@ static long ccu_nm_round_rate(struct clk_hw *hw, unsigned long rate,
 			      unsigned long *parent_rate)
 {
 	struct ccu_nm *nm = hw_to_ccu_nm(hw);
-	struct _ccu_nm _nm;
+	struct ccu_nm_params params;
 
 	if (nm->common.features & CCU_FEATURE_FIXED_POSTDIV)
 		rate *= nm->fixed_post_div;
@@ -145,18 +140,21 @@ static long ccu_nm_round_rate(struct clk_hw *hw, unsigned long rate,
 		return rate;
 	}
 
-	if (ccu_sdm_helper_has_rate(&nm->common, &nm->sdm, rate)) {
+	params.min_n = nm->n.min ?: 1;
+	params.max_n = nm->n.max ?: 1 << nm->n.width;
+	params.min_m = 1;
+	params.max_m = nm->m.max ?: 1 << nm->m.width;
+	params.min_rate = nm->min_rate;
+	params.max_rate = nm->max_rate;
+
+	if (nm->common.features & CCU_FEATURE_SIGMA_DELTA_MOD) {
+		rate = ccu_sdm_helper_round_rate(&nm->common, &nm->sdm, *parent_rate, rate, &params);
 		if (nm->common.features & CCU_FEATURE_FIXED_POSTDIV)
 			rate /= nm->fixed_post_div;
 		return rate;
 	}
 
-	_nm.min_n = nm->n.min ?: 1;
-	_nm.max_n = nm->n.max ?: 1 << nm->n.width;
-	_nm.min_m = 1;
-	_nm.max_m = nm->m.max ?: 1 << nm->m.width;
-
-	rate = ccu_nm_find_best(&nm->common, *parent_rate, rate, &_nm);
+	rate = ccu_nm_find_best(&nm->common, *parent_rate, rate, &params);
 
 	if (nm->common.features & CCU_FEATURE_FIXED_POSTDIV)
 		rate /= nm->fixed_post_div;
@@ -168,7 +166,7 @@ static int ccu_nm_set_rate(struct clk_hw *hw, unsigned long rate,
 			   unsigned long parent_rate)
 {
 	struct ccu_nm *nm = hw_to_ccu_nm(hw);
-	struct _ccu_nm _nm;
+	struct ccu_nm_params params;
 	unsigned long flags;
 	u32 reg;
 
@@ -194,20 +192,17 @@ static int ccu_nm_set_rate(struct clk_hw *hw, unsigned long rate,
 		ccu_frac_helper_disable(&nm->common, &nm->frac);
 	}
 
-	_nm.min_n = nm->n.min ?: 1;
-	_nm.max_n = nm->n.max ?: 1 << nm->n.width;
-	_nm.min_m = 1;
-	_nm.max_m = nm->m.max ?: 1 << nm->m.width;
-
-	if (ccu_sdm_helper_has_rate(&nm->common, &nm->sdm, rate)) {
-		ccu_sdm_helper_enable(&nm->common, &nm->sdm, rate);
+	params.min_n = nm->n.min ?: 1;
+	params.max_n = nm->n.max ?: 1 << nm->n.width;
+	params.min_m = 1;
+	params.max_m = nm->m.max ?: 1 << nm->m.width;
+	params.min_rate = nm->min_rate;
+	params.max_rate = nm->max_rate;
 
-		/* Sigma delta modulation requires specific N and M factors */
-		ccu_sdm_helper_get_factors(&nm->common, &nm->sdm, rate,
-					   &_nm.m, &_nm.n);
+	if (nm->common.features & CCU_FEATURE_SIGMA_DELTA_MOD) {
+		ccu_sdm_helper_set_rate(&nm->common, &nm->sdm, parent_rate, rate, &params);
 	} else {
-		ccu_sdm_helper_disable(&nm->common, &nm->sdm);
-		ccu_nm_find_best(&nm->common, parent_rate, rate, &_nm);
+		ccu_nm_find_best(&nm->common, parent_rate, rate, &params);
 	}
 
 	spin_lock_irqsave(nm->common.lock, flags);
@@ -216,8 +211,8 @@ static int ccu_nm_set_rate(struct clk_hw *hw, unsigned long rate,
 	reg &= ~GENMASK(nm->n.width + nm->n.shift - 1, nm->n.shift);
 	reg &= ~GENMASK(nm->m.width + nm->m.shift - 1, nm->m.shift);
 
-	reg |= (_nm.n - nm->n.offset) << nm->n.shift;
-	reg |= (_nm.m - nm->m.offset) << nm->m.shift;
+	reg |= (params.n - nm->n.offset) << nm->n.shift;
+	reg |= (params.m - nm->m.offset) << nm->m.shift;
 	writel(reg, nm->common.base + nm->common.reg);
 
 	spin_unlock_irqrestore(nm->common.lock, flags);
diff --git a/drivers/clk/sunxi-ng/ccu_nm.h b/drivers/clk/sunxi-ng/ccu_nm.h
index 93c11693574f..d41522c36730 100644
--- a/drivers/clk/sunxi-ng/ccu_nm.h
+++ b/drivers/clk/sunxi-ng/ccu_nm.h
@@ -38,7 +38,7 @@ struct ccu_nm {
 #define SUNXI_CCU_NM_WITH_SDM_GATE_LOCK(_struct, _name, _parent, _reg,	\
 					_nshift, _nwidth,		\
 					_mshift, _mwidth,		\
-					_sdm_table, _sdm_en,		\
+					_sdm_en,			\
 					_sdm_reg, _sdm_reg_en,		\
 					_gate, _lock, _flags)		\
 	struct ccu_nm _struct = {					\
@@ -46,8 +46,8 @@ struct ccu_nm {
 		.lock		= _lock,				\
 		.n		= _SUNXI_CCU_MULT(_nshift, _nwidth),	\
 		.m		= _SUNXI_CCU_DIV(_mshift, _mwidth),	\
-		.sdm		= _SUNXI_CCU_SDM(_sdm_table, _sdm_en,	\
-						 _sdm_reg, _sdm_reg_en),\
+		.sdm		= _SUNXI_CCU_SDM(_sdm_en, _sdm_reg,	\
+						 _sdm_reg_en),		\
 		.common		= {					\
 			.reg		= _reg,				\
 			.features	= CCU_FEATURE_SIGMA_DELTA_MOD,	\
diff --git a/drivers/clk/sunxi-ng/ccu_sdm.c b/drivers/clk/sunxi-ng/ccu_sdm.c
index 41937ed0766d..86d6537e9f29 100644
--- a/drivers/clk/sunxi-ng/ccu_sdm.c
+++ b/drivers/clk/sunxi-ng/ccu_sdm.c
@@ -9,153 +9,143 @@
 
 #include "ccu_sdm.h"
 
-bool ccu_sdm_helper_is_enabled(struct ccu_common *common,
-			       struct ccu_sdm_internal *sdm)
-{
-	if (!(common->features & CCU_FEATURE_SIGMA_DELTA_MOD))
-		return false;
-
-	if (sdm->enable && !(readl(common->base + common->reg) & sdm->enable))
-		return false;
-
-	return !!(readl(common->base + sdm->tuning_reg) & sdm->tuning_enable);
-}
-EXPORT_SYMBOL_NS_GPL(ccu_sdm_helper_is_enabled, SUNXI_CCU);
-
-void ccu_sdm_helper_enable(struct ccu_common *common,
-			   struct ccu_sdm_internal *sdm,
-			   unsigned long rate)
+static void ccu_sdm_set_wave_bottom(struct ccu_common *common,
+				    struct ccu_sdm_internal *sdm,
+				    int wave_bottom)
 {
 	unsigned long flags;
-	unsigned int i;
 	u32 reg;
 
 	if (!(common->features & CCU_FEATURE_SIGMA_DELTA_MOD))
 		return;
 
-	/* Set the pattern */
-	for (i = 0; i < sdm->table_size; i++)
-		if (sdm->table[i].rate == rate)
-			writel(sdm->table[i].pattern,
-			       common->base + sdm->tuning_reg);
-
-	/* Make sure SDM is enabled */
-	spin_lock_irqsave(common->lock, flags);
-	reg = readl(common->base + sdm->tuning_reg);
-	writel(reg | sdm->tuning_enable, common->base + sdm->tuning_reg);
-	spin_unlock_irqrestore(common->lock, flags);
+	unsigned long pattern = 0xc0000000 | (wave_bottom & 0x1FFFF);
+	writel(pattern, common->base + sdm->tuning_reg);
 
 	spin_lock_irqsave(common->lock, flags);
 	reg = readl(common->base + common->reg);
-	writel(reg | sdm->enable, common->base + common->reg);
+	if (wave_bottom != 0)
+		writel(reg | sdm->enable, common->base + common->reg);
+	else
+		writel(reg & ~sdm->enable, common->base + common->reg);
+	reg = readl(common->base + sdm->tuning_reg);
+	if (wave_bottom != 0)
+		writel(reg | sdm->tuning_enable, common->base + sdm->tuning_reg);
+	else
+		writel(reg & ~sdm->tuning_enable, common->base + sdm->tuning_reg);
 	spin_unlock_irqrestore(common->lock, flags);
 }
-EXPORT_SYMBOL_NS_GPL(ccu_sdm_helper_enable, SUNXI_CCU);
 
-void ccu_sdm_helper_disable(struct ccu_common *common,
-			    struct ccu_sdm_internal *sdm)
+static unsigned long ccu_sdm_calc_params(unsigned long parent,
+				  unsigned long rate,
+				  struct ccu_nm_params *params,
+				  int *wave_bottom)
 {
-	unsigned long flags;
-	u32 reg;
+	/* Defines */
+	#define GIGAPOINT  (uint64_t)1000000000
+	#define GIGAPLIER  (uint64_t)1000
+	#define WAVE_SCALE (uint64_t)131072 /* 2**17 */
+
+	/* Scaled variables */
+	uint64_t source_mhz = div_u64(parent, (uint64_t)1000000);
+	uint64_t target = rate * GIGAPLIER;
+	uint64_t clk_min = params->min_rate;
+	uint64_t clk_max = params->max_rate;
+
+	/* Best variables */
+	int best_wave_bottom_offset = WAVE_SCALE;
+	int best_N = 0;
+	int best_M = 0;
+	int best_wave_bottom = 0;
+	uint64_t best_real_target = 0;
+
+	for(int M = params->min_m; M <= params->max_m; ++M) {
+		/* Calculate desired N */
+		uint64_t N = div_u64(target, source_mhz) * M;
+		uint64_t N_decimal;
+		uint64_t N_integer = div64_u64_rem(N, GIGAPOINT, &N_decimal);
+		bool in_range_N = params->min_n <= N_integer && N_integer <= params->max_n;
+		if(!in_range_N)
+			continue;
+
+		/* Calculate wave bottom */
+		uint64_t wave_bottom = div_u64(N_decimal * 131072, GIGAPOINT);
+
+		/* Calculate how close it is to 0.5 */
+		uint64_t wave_bottom_half = WAVE_SCALE / 2;
+		uint64_t wave_bottom_offset = abs(wave_bottom_half - wave_bottom);
+
+		/* Calculate actual target frequency */
+		uint64_t wave_bottom_decimal = div_u64(wave_bottom * GIGAPOINT, 131072);
+		uint64_t real_N = (N_integer * GIGAPOINT) + wave_bottom_decimal;
+		uint64_t real_target = div_u64(source_mhz * real_N, M * GIGAPLIER);
+		bool in_range_hz = clk_min <= real_target && real_target <= clk_max;
+		if(!in_range_hz)
+			continue;
+
+		/* Update best variables if wave bottom is closer to 0.5 */
+		if(wave_bottom_offset < best_wave_bottom_offset) {
+			best_wave_bottom_offset = wave_bottom_offset;
+			best_N = N_integer;
+			best_M = M;
+			best_wave_bottom = wave_bottom;
+			best_real_target = real_target;
+		}
+	}
+	params->n = best_N;
+	params->m = best_M;
+	*wave_bottom = best_wave_bottom;
+	return best_real_target;
+}
 
+unsigned long ccu_sdm_helper_calc_rate(struct ccu_common *common,
+			   struct ccu_sdm_internal *sdm,
+			   unsigned long parent,
+			   unsigned long m,
+			   unsigned long n)
+{
 	if (!(common->features & CCU_FEATURE_SIGMA_DELTA_MOD))
-		return;
+		return 0;
 
-	spin_lock_irqsave(common->lock, flags);
-	reg = readl(common->base + common->reg);
-	writel(reg & ~sdm->enable, common->base + common->reg);
-	spin_unlock_irqrestore(common->lock, flags);
+	unsigned long flags;
 
 	spin_lock_irqsave(common->lock, flags);
-	reg = readl(common->base + sdm->tuning_reg);
-	writel(reg & ~sdm->tuning_enable, common->base + sdm->tuning_reg);
+	u32 wave_bottom = readl(common->base + sdm->tuning_reg) & 0x1FFFF;
 	spin_unlock_irqrestore(common->lock, flags);
-}
-EXPORT_SYMBOL_NS_GPL(ccu_sdm_helper_disable, SUNXI_CCU);
-
-/*
- * Sigma delta modulation provides a way to do fractional-N frequency
- * synthesis, in essence allowing the PLL to output any frequency
- * within its operational range. On earlier SoCs such as the A10/A20,
- * some PLLs support this. On later SoCs, all PLLs support this.
- *
- * The datasheets do not explain what the "wave top" and "wave bottom"
- * parameters mean or do, nor how to calculate the effective output
- * frequency. The only examples (and real world usage) are for the audio
- * PLL to generate 24.576 and 22.5792 MHz clock rates used by the audio
- * peripherals. The author lacks the underlying domain knowledge to
- * pursue this.
- *
- * The goal and function of the following code is to support the two
- * clock rates used by the audio subsystem, allowing for proper audio
- * playback and capture without any pitch or speed changes.
- */
-bool ccu_sdm_helper_has_rate(struct ccu_common *common,
-			     struct ccu_sdm_internal *sdm,
-			     unsigned long rate)
-{
-	unsigned int i;
 
-	if (!(common->features & CCU_FEATURE_SIGMA_DELTA_MOD))
-		return false;
-
-	for (i = 0; i < sdm->table_size; i++)
-		if (sdm->table[i].rate == rate)
-			return true;
+	/* Calculate actual target frequency */
+	uint64_t source_mhz = div_u64(parent, (uint64_t)1000000);
+	uint64_t wave_bottom_decimal = div_u64(wave_bottom * GIGAPOINT, 131072);
+	uint64_t real_N = (n * GIGAPOINT) + wave_bottom_decimal;
+	uint64_t real_target = div_u64(source_mhz * real_N, m * GIGAPLIER);
 
-	return false;
+	return real_target;
 }
-EXPORT_SYMBOL_NS_GPL(ccu_sdm_helper_has_rate, SUNXI_CCU);
-
-unsigned long ccu_sdm_helper_read_rate(struct ccu_common *common,
-				       struct ccu_sdm_internal *sdm,
-				       u32 m, u32 n)
-{
-	unsigned int i;
-	u32 reg;
 
-	pr_debug("%s: Read sigma-delta modulation setting\n",
-		 clk_hw_get_name(&common->hw));
 
+unsigned long ccu_sdm_helper_round_rate(struct ccu_common *common,
+			   struct ccu_sdm_internal *sdm,
+			   unsigned long parent,
+			   unsigned long rate,
+			   struct ccu_nm_params *params)
+{
 	if (!(common->features & CCU_FEATURE_SIGMA_DELTA_MOD))
 		return 0;
-
-	pr_debug("%s: clock is sigma-delta modulated\n",
-		 clk_hw_get_name(&common->hw));
-
-	reg = readl(common->base + sdm->tuning_reg);
-
-	pr_debug("%s: pattern reg is 0x%x",
-		 clk_hw_get_name(&common->hw), reg);
-
-	for (i = 0; i < sdm->table_size; i++)
-		if (sdm->table[i].pattern == reg &&
-		    sdm->table[i].m == m && sdm->table[i].n == n)
-			return sdm->table[i].rate;
-
-	/* We can't calculate the effective clock rate, so just fail. */
-	return 0;
+	
+	int wave_bottom = 0;
+	return ccu_sdm_calc_params(parent, rate, params, &wave_bottom);
 }
-EXPORT_SYMBOL_NS_GPL(ccu_sdm_helper_read_rate, SUNXI_CCU);
 
-int ccu_sdm_helper_get_factors(struct ccu_common *common,
-			       struct ccu_sdm_internal *sdm,
-			       unsigned long rate,
-			       unsigned long *m, unsigned long *n)
+void ccu_sdm_helper_set_rate(struct ccu_common *common,
+			   struct ccu_sdm_internal *sdm,
+			   unsigned long parent,
+			   unsigned long rate,
+			   struct ccu_nm_params *params)
 {
-	unsigned int i;
-
 	if (!(common->features & CCU_FEATURE_SIGMA_DELTA_MOD))
-		return -EINVAL;
-
-	for (i = 0; i < sdm->table_size; i++)
-		if (sdm->table[i].rate == rate) {
-			*m = sdm->table[i].m;
-			*n = sdm->table[i].n;
-			return 0;
-		}
+		return;
 
-	/* nothing found */
-	return -EINVAL;
+	int wave_bottom = 0;
+	ccu_sdm_calc_params(parent, rate, params, &wave_bottom);
+	ccu_sdm_set_wave_bottom(common, sdm, wave_bottom);
 }
-EXPORT_SYMBOL_NS_GPL(ccu_sdm_helper_get_factors, SUNXI_CCU);
diff --git a/drivers/clk/sunxi-ng/ccu_sdm.h b/drivers/clk/sunxi-ng/ccu_sdm.h
index c1a7159b89c3..2fc25bca49e4 100644
--- a/drivers/clk/sunxi-ng/ccu_sdm.h
+++ b/drivers/clk/sunxi-ng/ccu_sdm.h
@@ -10,27 +10,7 @@
 
 #include "ccu_common.h"
 
-struct ccu_sdm_setting {
-	unsigned long	rate;
-
-	/*
-	 * XXX We don't know what the step and bottom register fields
-	 * mean. Just copy the whole register value from the vendor
-	 * kernel for now.
-	 */
-	u32		pattern;
-
-	/*
-	 * M and N factors here should be the values used in
-	 * calculation, not the raw values written to registers
-	 */
-	u32		m;
-	u32		n;
-};
-
 struct ccu_sdm_internal {
-	struct ccu_sdm_setting	*table;
-	u32		table_size;
 	/* early SoCs don't have the SDM enable bit in the PLL register */
 	u32		enable;
 	/* second enable bit in tuning register */
@@ -38,35 +18,29 @@ struct ccu_sdm_internal {
 	u16		tuning_reg;
 };
 
-#define _SUNXI_CCU_SDM(_table, _enable,			\
-		       _reg, _reg_enable)		\
+#define _SUNXI_CCU_SDM(_enable, _reg, _reg_enable)	\
 	{						\
-		.table		= _table,		\
-		.table_size	= ARRAY_SIZE(_table),	\
 		.enable		= _enable,		\
 		.tuning_enable	= _reg_enable,		\
 		.tuning_reg	= _reg,			\
 	}
 
-bool ccu_sdm_helper_is_enabled(struct ccu_common *common,
-			       struct ccu_sdm_internal *sdm);
-void ccu_sdm_helper_enable(struct ccu_common *common,
+unsigned long ccu_sdm_helper_calc_rate(struct ccu_common *common,
 			   struct ccu_sdm_internal *sdm,
-			   unsigned long rate);
-void ccu_sdm_helper_disable(struct ccu_common *common,
-			    struct ccu_sdm_internal *sdm);
+			   unsigned long parent,
+			   unsigned long m,
+			   unsigned long n);
 
-bool ccu_sdm_helper_has_rate(struct ccu_common *common,
-			     struct ccu_sdm_internal *sdm,
-			     unsigned long rate);
-
-unsigned long ccu_sdm_helper_read_rate(struct ccu_common *common,
-				       struct ccu_sdm_internal *sdm,
-				       u32 m, u32 n);
+unsigned long ccu_sdm_helper_round_rate(struct ccu_common *common,
+			   struct ccu_sdm_internal *sdm,
+			   unsigned long parent,
+			   unsigned long rate,
+			   struct ccu_nm_params *params);
 
-int ccu_sdm_helper_get_factors(struct ccu_common *common,
-			       struct ccu_sdm_internal *sdm,
-			       unsigned long rate,
-			       unsigned long *m, unsigned long *n);
+void ccu_sdm_helper_set_rate(struct ccu_common *common,
+			   struct ccu_sdm_internal *sdm,
+			   unsigned long parent,
+			   unsigned long rate,
+			   struct ccu_nm_params *params);
 
 #endif
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 59f9742e9ff4..b4cb23ee8375 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -98,6 +98,7 @@ config SND_SOC_ALL_CODECS
 	imply SND_SOC_CS47L85
 	imply SND_SOC_CS47L90
 	imply SND_SOC_CS47L92
+	imply SND_SOC_CS5368
 	imply SND_SOC_CS53L30
 	imply SND_SOC_CX20442
 	imply SND_SOC_CX2072X
@@ -971,6 +972,11 @@ config SND_SOC_CS47L92
 	tristate
 	depends on MFD_CS47L92
 
+config SND_SOC_CS5368
+	tristate "Cirrus Logic CS5368 CODEC"
+	depends on I2C
+	depends on OF
+
 # Cirrus Logic Quad-Channel ADC
 config SND_SOC_CS53L30
 	tristate "Cirrus Logic CS53L30 CODEC"
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index f53baa2b9565..5ec9004ec91b 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -104,6 +104,7 @@ snd-soc-cs47l35-objs := cs47l35.o
 snd-soc-cs47l85-objs := cs47l85.o
 snd-soc-cs47l90-objs := cs47l90.o
 snd-soc-cs47l92-objs := cs47l92.o
+snd-soc-cs5368-objs := cs5368.o
 snd-soc-cs53l30-objs := cs53l30.o
 snd-soc-cx20442-objs := cx20442.o
 snd-soc-cx2072x-objs := cx2072x.o
@@ -494,6 +495,7 @@ obj-$(CONFIG_SND_SOC_CS47L35)	+= snd-soc-cs47l35.o
 obj-$(CONFIG_SND_SOC_CS47L85)	+= snd-soc-cs47l85.o
 obj-$(CONFIG_SND_SOC_CS47L90)	+= snd-soc-cs47l90.o
 obj-$(CONFIG_SND_SOC_CS47L92)	+= snd-soc-cs47l92.o
+obj-$(CONFIG_SND_SOC_CS5368)	+= snd-soc-cs5368.o
 obj-$(CONFIG_SND_SOC_CS53L30)	+= snd-soc-cs53l30.o
 obj-$(CONFIG_SND_SOC_CX20442)	+= snd-soc-cx20442.o
 obj-$(CONFIG_SND_SOC_CX2072X)	+= snd-soc-cx2072x.o
diff --git a/sound/soc/codecs/cs5368.c b/sound/soc/codecs/cs5368.c
new file mode 100644
index 000000000000..d5771fa543cb
--- /dev/null
+++ b/sound/soc/codecs/cs5368.c
@@ -0,0 +1,407 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+// Copyright 2024 John Watts <contact@jookia.org>
+
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <sound/soc.h>
+
+#define REG_REVI 0x00
+#define REG_GCTL 0x01
+#define REG_OVFL 0x02
+#define REG_OVFM 0x03
+#define REG_HPF 0x04
+#define REG_RSVD1 0x05
+#define REG_PDN 0x06
+#define REG_RSVD2 0x07
+#define REG_MUTE 0x08
+#define REG_RSVD3 0x09
+#define REG_SDEN 0x0A
+#define MAX_REG REG_SDEN
+
+static const struct reg_sequence cs5368_reg_init[] = {
+	{ REG_GCTL, 0x8B }, /* CP-EN, TDM format, slave audio clocking */
+	{ REG_OVFM, 0x00 }, /* Mask all overflows */
+	{ REG_SDEN, 0x0A }, /* Only enable TDM and _TDM pins */
+};
+
+static const struct reg_default cs5368_reg_defaults[] = {
+	{ REG_REVI, 0x80 }, /* Assume revision A by default */
+	{ REG_GCTL, 0x00 },
+	{ REG_OVFL, 0xFF },
+	{ REG_OVFM, 0xFF },
+	{ REG_HPF,  0x00 },
+	{ REG_PDN,  0x00 },
+	{ REG_MUTE, 0x00 },
+	{ REG_SDEN, 0x00 },
+};
+
+static const struct regmap_range cs5368_rd_no_ranges[] = {
+	regmap_reg_range(REG_RSVD1, REG_RSVD1),
+	regmap_reg_range(REG_RSVD2, REG_RSVD2),
+	regmap_reg_range(REG_RSVD3, REG_RSVD3),
+};
+
+static const struct regmap_range cs5368_wr_no_ranges[] = {
+	regmap_reg_range(REG_REVI,  REG_REVI),
+	regmap_reg_range(REG_RSVD1, REG_RSVD1),
+	regmap_reg_range(REG_RSVD2, REG_RSVD2),
+	regmap_reg_range(REG_RSVD3, REG_RSVD3),
+};
+
+static const struct regmap_range cs5368_volatile_yes_ranges[] = {
+	regmap_reg_range(REG_OVFL, REG_OVFL),
+};
+
+static const struct regmap_access_table cs5368_rd_table = {
+	.no_ranges = cs5368_rd_no_ranges,
+	.n_no_ranges = ARRAY_SIZE(cs5368_rd_no_ranges),
+};
+
+static const struct regmap_access_table cs5368_wr_table = {
+	.no_ranges = cs5368_wr_no_ranges,
+	.n_no_ranges = ARRAY_SIZE(cs5368_wr_no_ranges),
+};
+
+static const struct regmap_access_table cs5368_volatile_table = {
+	.yes_ranges = cs5368_volatile_yes_ranges,
+	.n_yes_ranges = ARRAY_SIZE(cs5368_volatile_yes_ranges),
+};
+
+static const struct regmap_config cs5368_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+	.reg_defaults = cs5368_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(cs5368_reg_defaults),
+	.max_register = MAX_REG,
+	.rd_table = &cs5368_rd_table,
+	.wr_table = &cs5368_wr_table,
+	.volatile_table = &cs5368_volatile_table,
+	.read_flag_mask = 0x80, /* Set INCR bit so batch reads work */
+	.write_flag_mask = 0x80, /* Set INCR bit so batch writes work */
+};
+
+static const char *supply_names[] = {
+	"vdd", /* Usually 3.3V logic */
+	"vdda", /* Usually 5V logic */
+};
+
+struct cs5368_priv {
+	struct regulator_bulk_data regulators[ARRAY_SIZE(supply_names)];
+	struct gpio_desc *reset_gpio;
+	struct regmap *regmap;
+	int mclk;
+};
+
+static const struct snd_kcontrol_new cs5368_snd_controls[] = {
+	SOC_SINGLE("AIN1 High-Pass Filter Switch", 0x4, 0, 1, 1),
+	SOC_SINGLE("AIN2 High-Pass Filter Switch", 0x4, 1, 1, 1),
+	SOC_SINGLE("AIN3 High-Pass Filter Switch", 0x4, 2, 1, 1),
+	SOC_SINGLE("AIN4 High-Pass Filter Switch", 0x4, 3, 1, 1),
+	SOC_SINGLE("AIN5 High-Pass Filter Switch", 0x4, 4, 1, 1),
+	SOC_SINGLE("AIN6 High-Pass Filter Switch", 0x4, 5, 1, 1),
+	SOC_SINGLE("AIN7 High-Pass Filter Switch", 0x4, 6, 1, 1),
+	SOC_SINGLE("AIN8 High-Pass Filter Switch", 0x4, 7, 1, 1),
+};
+
+static const struct snd_kcontrol_new cs5368_snd_controls_mute_ain1 =
+	SOC_DAPM_SINGLE("Switch", 0x8, 0, 1, 1);
+static const struct snd_kcontrol_new cs5368_snd_controls_mute_ain2 =
+	SOC_DAPM_SINGLE("Switch", 0x8, 1, 1, 1);
+static const struct snd_kcontrol_new cs5368_snd_controls_mute_ain3 =
+	SOC_DAPM_SINGLE("Switch", 0x8, 2, 1, 1);
+static const struct snd_kcontrol_new cs5368_snd_controls_mute_ain4 =
+	SOC_DAPM_SINGLE("Switch", 0x8, 3, 1, 1);
+static const struct snd_kcontrol_new cs5368_snd_controls_mute_ain5 =
+	SOC_DAPM_SINGLE("Switch", 0x8, 4, 1, 1);
+static const struct snd_kcontrol_new cs5368_snd_controls_mute_ain6 =
+	SOC_DAPM_SINGLE("Switch", 0x8, 5, 1, 1);
+static const struct snd_kcontrol_new cs5368_snd_controls_mute_ain7 =
+	SOC_DAPM_SINGLE("Switch", 0x8, 6, 1, 1);
+static const struct snd_kcontrol_new cs5368_snd_controls_mute_ain8 =
+	SOC_DAPM_SINGLE("Switch", 0x8, 7, 1, 1);
+
+static const struct snd_soc_dapm_widget cs5368_dapm_widgets[] = {
+	SND_SOC_DAPM_INPUT("AIN1"),
+	SND_SOC_DAPM_INPUT("AIN2"),
+	SND_SOC_DAPM_INPUT("AIN3"),
+	SND_SOC_DAPM_INPUT("AIN4"),
+	SND_SOC_DAPM_INPUT("AIN5"),
+	SND_SOC_DAPM_INPUT("AIN6"),
+	SND_SOC_DAPM_INPUT("AIN7"),
+	SND_SOC_DAPM_INPUT("AIN8"),
+	SND_SOC_DAPM_ADC("AIN12", NULL, 0x6, 0, 1),
+	SND_SOC_DAPM_ADC("AIN34", NULL, 0x6, 1, 1),
+	SND_SOC_DAPM_ADC("AIN56", NULL, 0x6, 2, 1),
+	SND_SOC_DAPM_ADC("AIN78", NULL, 0x6, 3, 1),
+	SND_SOC_DAPM_SWITCH("AIN1 Capture", SND_SOC_NOPM, 0, 0, &cs5368_snd_controls_mute_ain1),
+	SND_SOC_DAPM_SWITCH("AIN2 Capture", SND_SOC_NOPM, 0, 0, &cs5368_snd_controls_mute_ain2),
+	SND_SOC_DAPM_SWITCH("AIN3 Capture", SND_SOC_NOPM, 0, 0, &cs5368_snd_controls_mute_ain3),
+	SND_SOC_DAPM_SWITCH("AIN4 Capture", SND_SOC_NOPM, 0, 0, &cs5368_snd_controls_mute_ain4),
+	SND_SOC_DAPM_SWITCH("AIN5 Capture", SND_SOC_NOPM, 0, 0, &cs5368_snd_controls_mute_ain5),
+	SND_SOC_DAPM_SWITCH("AIN6 Capture", SND_SOC_NOPM, 0, 0, &cs5368_snd_controls_mute_ain6),
+	SND_SOC_DAPM_SWITCH("AIN7 Capture", SND_SOC_NOPM, 0, 0, &cs5368_snd_controls_mute_ain7),
+	SND_SOC_DAPM_SWITCH("AIN8 Capture", SND_SOC_NOPM, 0, 0, &cs5368_snd_controls_mute_ain8),
+	SND_SOC_DAPM_AIF_OUT("TDM1", "Capture", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("TDM2", "Capture", 2, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("TDM3", "Capture", 4, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("TDM4", "Capture", 6, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("TDM5", "Capture", 1, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("TDM6", "Capture", 3, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("TDM7", "Capture", 5, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("TDM8", "Capture", 7, SND_SOC_NOPM, 0, 0),
+};
+
+static const struct snd_soc_dapm_route cs5368_dapm_routes[] = {
+	{ "AIN12", NULL, "AIN1" },
+	{ "AIN12", NULL, "AIN2" },
+	{ "AIN34", NULL, "AIN3" },
+	{ "AIN34", NULL, "AIN4" },
+	{ "AIN56", NULL, "AIN5" },
+	{ "AIN56", NULL, "AIN6" },
+	{ "AIN78", NULL, "AIN7" },
+	{ "AIN78", NULL, "AIN8" },
+	{ "AIN1 Capture", "Switch", "AIN12" },
+	{ "AIN2 Capture", "Switch", "AIN12" },
+	{ "AIN3 Capture", "Switch", "AIN34" },
+	{ "AIN4 Capture", "Switch", "AIN34" },
+	{ "AIN5 Capture", "Switch", "AIN56" },
+	{ "AIN6 Capture", "Switch", "AIN56" },
+	{ "AIN7 Capture", "Switch", "AIN78" },
+	{ "AIN8 Capture", "Switch", "AIN78" },
+	{ "TDM1", NULL, "AIN1 Capture" },
+	{ "TDM2", NULL, "AIN2 Capture" },
+	{ "TDM3", NULL, "AIN3 Capture" },
+	{ "TDM4", NULL, "AIN4 Capture" },
+	{ "TDM5", NULL, "AIN5 Capture" },
+	{ "TDM6", NULL, "AIN6 Capture" },
+	{ "TDM7", NULL, "AIN7 Capture" },
+	{ "TDM8", NULL, "AIN8 Capture" },
+};
+
+static int cs5368_dai_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params,
+	struct snd_soc_dai *dai)
+{
+	struct cs5368_priv *priv = snd_soc_dai_get_drvdata(dai);
+	struct device *dev = dai->dev;
+
+	int rate = params_rate(params);
+	int fs = priv->mclk / rate;
+
+	if(fs && fs != 256) {
+		dev_err(dev, "mclk-fs must be 256\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cs5368_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+	unsigned int freq, int dir)
+{
+	struct cs5368_priv *priv = snd_soc_dai_get_drvdata(dai);
+	priv->mclk = freq;
+
+	return 0;
+}
+
+static int cs5368_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	int mode = fmt & SND_SOC_DAIFMT_FORMAT_MASK;
+	struct device *dev = dai->dev;
+
+	/*
+	 * The data sheet says the TDM format is 'left justified',
+	 * but it is actually standard I2S format.
+	 * The diagram (figure 12) seems to confirm this.
+	*/
+	if(mode != SND_SOC_DAIFMT_I2S) {
+		dev_err(dev, "codec only supports i2s format\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cs5368_dai_set_tdm_slot(struct snd_soc_dai *dai,
+	unsigned int tx_mask,
+	unsigned int rx_mask,
+	int slots, int slot_width)
+{
+	struct device *dev = dai->dev;
+
+	if(slots != 8) {
+		dev_err(dev, "codec requires 8 TDM slots\n");
+		return -EINVAL;
+	}
+
+	if(slot_width != 32) {
+		dev_err(dev, "codec requires 32-bit TDM slot width\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops snd_soc_dai_ops_cs5368 = {
+	.hw_params = cs5368_dai_hw_params,
+	.set_fmt = cs5368_dai_set_fmt,
+	.set_sysclk = cs5368_dai_set_sysclk,
+	.set_tdm_slot = cs5368_dai_set_tdm_slot,
+};
+
+struct snd_soc_dai_driver soc_dai_cs5368 = {
+	.capture = {
+		.channels_max = 8,
+		.channels_min = 8,
+		.formats = SNDRV_PCM_FMTBIT_S32_LE,
+		.rate_max = 216000,
+		.rate_min = 2000,
+		.rates = SNDRV_PCM_RATE_CONTINUOUS,
+		.sig_bits = 24,
+		.stream_name = "Capture",
+	},
+	.name = "cs5368",
+	.ops = &snd_soc_dai_ops_cs5368,
+};
+
+static const struct snd_soc_component_driver soc_component_dev_cs5368 = {
+	.controls = cs5368_snd_controls,
+	.dapm_routes = cs5368_dapm_routes,
+	.dapm_widgets = cs5368_dapm_widgets,
+	.endianness = 1,
+	.num_controls = ARRAY_SIZE(cs5368_snd_controls),
+	.num_dapm_routes = ARRAY_SIZE(cs5368_dapm_routes),
+	.num_dapm_widgets = ARRAY_SIZE(cs5368_dapm_widgets),
+};
+
+static int cs5368_i2c_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct cs5368_priv *priv;
+	int err;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, priv);
+
+	priv->regmap = devm_regmap_init_i2c(client, &cs5368_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		err = PTR_ERR(priv->regmap);
+		dev_err(dev, "regmap init failed: %d\n", err);
+		return err;
+	}
+	regcache_cache_only(priv->regmap, true);
+	err = regmap_multi_reg_write(priv->regmap, cs5368_reg_init, ARRAY_SIZE(cs5368_reg_init));
+	if (err) {
+		dev_err(dev, "regmap_multi_reg_write failed: %d\n", err);
+		return err;
+	}
+
+	regulator_bulk_set_supply_names(priv->regulators, supply_names, ARRAY_SIZE(priv->regulators));
+	err = devm_regulator_bulk_get(dev, ARRAY_SIZE(priv->regulators), priv->regulators);
+	if (err) {
+		dev_err(dev, "regulator_bulk_get failed: %d\n", err);
+		return err;
+	}
+
+	priv->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(priv->reset_gpio)) {
+		err = PTR_ERR(priv->reset_gpio);
+		dev_err(dev, "failed to get reset gpio: %d\n", err);
+		return err;
+	}
+
+	err = devm_pm_runtime_enable(dev);
+	if (err) {
+		dev_err(dev, "devm_pm_runtime_enable failed: %d\n", err);
+		return err;
+	}
+
+	return devm_snd_soc_register_component(&client->dev,
+			&soc_component_dev_cs5368, &soc_dai_cs5368, 1);
+}
+
+static int cs5368_pm_runtime_suspend(struct device *dev)
+{
+	struct cs5368_priv* priv = dev_get_drvdata(dev);
+	int err;
+
+	err = regcache_sync(priv->regmap);
+	regcache_cache_only(priv->regmap, true);
+	if (err) {
+		dev_err(dev, "regcache_sync failed: %d\n", err);
+		return err;
+	}
+
+	gpiod_set_value_cansleep(priv->reset_gpio, 1);
+
+	err = regulator_bulk_disable(ARRAY_SIZE(priv->regulators), priv->regulators);
+	if (err) {
+		dev_err(dev, "regulator_bulk_disable failed: %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+static int cs5368_pm_runtime_resume(struct device *dev)
+{
+	struct cs5368_priv* priv = dev_get_drvdata(dev);
+	int err;
+
+	err = regulator_bulk_enable(ARRAY_SIZE(priv->regulators), priv->regulators);
+	if (err) {
+		dev_err(dev, "regulator_bulk_enable failed: %d\n", err);
+		return err;
+	}
+
+	gpiod_set_value_cansleep(priv->reset_gpio, 0);
+
+	regcache_cache_only(priv->regmap, false);
+	regcache_mark_dirty(priv->regmap);
+	err = regcache_sync(priv->regmap);
+	if (err) {
+		dev_err(dev, "regcache_sync failed: %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id cs5368_of_match[] = {
+	{ .compatible = "cirrus,cs5368" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, cs5368_of_match);
+
+static const struct i2c_device_id cs5368_i2c_id[] = {
+	{ "cs5368", 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, cs5368_i2c_id);
+
+DEFINE_RUNTIME_DEV_PM_OPS(cs5368_pm_ops, cs5368_pm_runtime_suspend, cs5368_pm_runtime_resume, NULL);
+
+static struct i2c_driver cs5368_codec_driver = {
+	.driver = {
+		.name = "cs5368",
+		.of_match_table = cs5368_of_match,
+		.pm = pm_ptr(&cs5368_pm_ops),
+	},
+	.id_table = cs5368_i2c_id,
+	.probe = cs5368_i2c_probe,
+};
+module_i2c_driver(cs5368_codec_driver);
+
+MODULE_DESCRIPTION("ASoC CS5368 driver");
+MODULE_AUTHOR("John Watts <contact@jookia.org>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sun4i-i2s.c b/sound/soc/sunxi/sun4i-i2s.c
index 598b263f27f7..f9328c43fbac 100644
--- a/sound/soc/sunxi/sun4i-i2s.c
+++ b/sound/soc/sunxi/sun4i-i2s.c
@@ -167,7 +167,6 @@ struct sun4i_i2s;
  * @num_bclk_dividers: number of bit clock dividers
  * @mclk_dividers: mclk dividers array
  * @num_mclk_dividers: number of mclk dividers
- * @get_bclk_parent_rate: callback to get bclk parent rate
  * @get_sr: callback to get sample resolution
  * @get_wss: callback to get word select size
  * @set_chan_cfg: callback to set channel configuration
@@ -191,7 +190,6 @@ struct sun4i_i2s_quirks {
 	const struct sun4i_i2s_clk_div	*mclk_dividers;
 	unsigned int			num_mclk_dividers;
 
-	unsigned long (*get_bclk_parent_rate)(const struct sun4i_i2s *i2s);
 	int	(*get_sr)(unsigned int width);
 	int	(*get_wss)(unsigned int width);
 
@@ -344,126 +342,22 @@ static const struct sun4i_i2s_clk_div sun8i_i2s_clk_div[] = {
 	{ .div = 192, .val = 15 },
 };
 
-static unsigned long sun4i_i2s_get_bclk_parent_rate(const struct sun4i_i2s *i2s)
-{
-	return i2s->mclk_freq;
-}
-
-static unsigned long sun8i_i2s_get_bclk_parent_rate(const struct sun4i_i2s *i2s)
-{
-	return clk_get_rate(i2s->mod_clk);
-}
-
-static int sun4i_i2s_get_bclk_div(struct sun4i_i2s *i2s,
-				  unsigned long parent_rate,
-				  unsigned int sampling_rate,
-				  unsigned int channels,
-				  unsigned int word_size)
-{
-	const struct sun4i_i2s_clk_div *dividers = i2s->variant->bclk_dividers;
-	int div = parent_rate / sampling_rate / word_size / channels;
-	int i;
-
-	for (i = 0; i < i2s->variant->num_bclk_dividers; i++) {
-		const struct sun4i_i2s_clk_div *bdiv = &dividers[i];
-
-		if (bdiv->div == div)
-			return bdiv->val;
-	}
-
-	return -EINVAL;
-}
-
-static int sun4i_i2s_get_mclk_div(struct sun4i_i2s *i2s,
-				  unsigned long parent_rate,
-				  unsigned long mclk_rate)
-{
-	const struct sun4i_i2s_clk_div *dividers = i2s->variant->mclk_dividers;
-	int div = parent_rate / mclk_rate;
-	int i;
-
-	for (i = 0; i < i2s->variant->num_mclk_dividers; i++) {
-		const struct sun4i_i2s_clk_div *mdiv = &dividers[i];
-
-		if (mdiv->div == div)
-			return mdiv->val;
-	}
-
-	return -EINVAL;
-}
-
-static int sun4i_i2s_oversample_rates[] = { 128, 192, 256, 384, 512, 768 };
-static bool sun4i_i2s_oversample_is_valid(unsigned int oversample)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_oversample_rates); i++)
-		if (sun4i_i2s_oversample_rates[i] == oversample)
-			return true;
-
-	return false;
-}
-
 static int sun4i_i2s_set_clk_rate(struct snd_soc_dai *dai,
 				  unsigned int rate,
 				  unsigned int slots,
 				  unsigned int slot_width)
 {
 	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-	unsigned int oversample_rate, clk_rate, bclk_parent_rate;
-	int bclk_div, mclk_div;
-	int ret;
+	unsigned long mclk_rate, bclk_div, mclk_div;
 
-	switch (rate) {
-	case 176400:
-	case 88200:
-	case 44100:
-	case 22050:
-	case 11025:
-		clk_rate = 22579200;
-		break;
-
-	case 192000:
-	case 128000:
-	case 96000:
-	case 64000:
-	case 48000:
-	case 32000:
-	case 24000:
-	case 16000:
-	case 12000:
-	case 8000:
-		clk_rate = 24576000;
-		break;
-
-	default:
-		dev_err(dai->dev, "Unsupported sample rate: %u\n", rate);
-		return -EINVAL;
-	}
+	mclk_rate = rate * slots * slot_width;
+	bclk_div = 1;
+	mclk_div = 1;
 
-	ret = clk_set_rate(i2s->mod_clk, clk_rate);
-	if (ret)
+	int ret = clk_set_rate(i2s->mod_clk, mclk_rate);
+	if (ret < 0) {
+		dev_err(dai->dev, "Unable to set MCLK: %i", ret);
 		return ret;
-
-	oversample_rate = i2s->mclk_freq / rate;
-	if (!sun4i_i2s_oversample_is_valid(oversample_rate)) {
-		dev_err(dai->dev, "Unsupported oversample rate: %d\n",
-			oversample_rate);
-		return -EINVAL;
-	}
-
-	bclk_parent_rate = i2s->variant->get_bclk_parent_rate(i2s);
-	bclk_div = sun4i_i2s_get_bclk_div(i2s, bclk_parent_rate,
-					  rate, slots, slot_width);
-	if (bclk_div < 0) {
-		dev_err(dai->dev, "Unsupported BCLK divider: %d\n", bclk_div);
-		return -EINVAL;
-	}
-
-	mclk_div = sun4i_i2s_get_mclk_div(i2s, clk_rate, i2s->mclk_freq);
-	if (mclk_div < 0) {
-		dev_err(dai->dev, "Unsupported MCLK divider: %d\n", mclk_div);
-		return -EINVAL;
 	}
 
 	regmap_write(i2s->regmap, SUN4I_I2S_CLK_DIV_REG,
@@ -580,7 +474,7 @@ static int sun8i_i2s_set_chan_cfg(const struct sun4i_i2s *i2s,
 	case SND_SOC_DAIFMT_LEFT_J:
 	case SND_SOC_DAIFMT_RIGHT_J:
 	case SND_SOC_DAIFMT_I2S:
-		lrck_period = slot_width;
+		lrck_period = slot_width * slots / 2;
 		break;
 
 	default:
@@ -660,7 +554,7 @@ static int sun50i_h6_i2s_set_chan_cfg(const struct sun4i_i2s *i2s,
 	case SND_SOC_DAIFMT_LEFT_J:
 	case SND_SOC_DAIFMT_RIGHT_J:
 	case SND_SOC_DAIFMT_I2S:
-		lrck_period = slot_width;
+		lrck_period = slot_width * slots / 2;
 		break;
 
 	default:
@@ -1193,21 +1087,26 @@ static const struct snd_soc_dai_ops sun4i_i2s_dai_ops = {
 
 #define SUN4I_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
 			 SNDRV_PCM_FMTBIT_S20_LE | \
-			 SNDRV_PCM_FMTBIT_S24_LE)
+			 SNDRV_PCM_FMTBIT_S24_LE | \
+			 SNDRV_PCM_FMTBIT_S32_LE)
 
 static struct snd_soc_dai_driver sun4i_i2s_dai = {
 	.capture = {
 		.stream_name = "Capture",
 		.channels_min = 1,
-		.channels_max = 8,
-		.rates = SNDRV_PCM_RATE_8000_192000,
+		.channels_max = 64,
+		.rates = SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_KNOT,
+		.rate_min = 1000,
+		.rate_max = 384000,
 		.formats = SUN4I_FORMATS,
 	},
 	.playback = {
 		.stream_name = "Playback",
 		.channels_min = 1,
 		.channels_max = 8,
-		.rates = SNDRV_PCM_RATE_8000_192000,
+		.rates = SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_KNOT,
+		.rate_min = 1000,
+		.rate_max = 384000,
 		.formats = SUN4I_FORMATS,
 	},
 	.ops = &sun4i_i2s_dai_ops,
@@ -1441,7 +1340,6 @@ static const struct sun4i_i2s_quirks sun4i_a10_i2s_quirks = {
 	.num_bclk_dividers	= ARRAY_SIZE(sun4i_i2s_bclk_div),
 	.mclk_dividers		= sun4i_i2s_mclk_div,
 	.num_mclk_dividers	= ARRAY_SIZE(sun4i_i2s_mclk_div),
-	.get_bclk_parent_rate	= sun4i_i2s_get_bclk_parent_rate,
 	.get_sr			= sun4i_i2s_get_sr,
 	.get_wss		= sun4i_i2s_get_wss,
 	.set_chan_cfg		= sun4i_i2s_set_chan_cfg,
@@ -1459,7 +1357,6 @@ static const struct sun4i_i2s_quirks sun6i_a31_i2s_quirks = {
 	.num_bclk_dividers	= ARRAY_SIZE(sun4i_i2s_bclk_div),
 	.mclk_dividers		= sun4i_i2s_mclk_div,
 	.num_mclk_dividers	= ARRAY_SIZE(sun4i_i2s_mclk_div),
-	.get_bclk_parent_rate	= sun4i_i2s_get_bclk_parent_rate,
 	.get_sr			= sun4i_i2s_get_sr,
 	.get_wss		= sun4i_i2s_get_wss,
 	.set_chan_cfg		= sun4i_i2s_set_chan_cfg,
@@ -1482,7 +1379,6 @@ static const struct sun4i_i2s_quirks sun8i_a83t_i2s_quirks = {
 	.num_bclk_dividers	= ARRAY_SIZE(sun4i_i2s_bclk_div),
 	.mclk_dividers		= sun4i_i2s_mclk_div,
 	.num_mclk_dividers	= ARRAY_SIZE(sun4i_i2s_mclk_div),
-	.get_bclk_parent_rate	= sun4i_i2s_get_bclk_parent_rate,
 	.get_sr			= sun4i_i2s_get_sr,
 	.get_wss		= sun4i_i2s_get_wss,
 	.set_chan_cfg		= sun4i_i2s_set_chan_cfg,
@@ -1500,7 +1396,6 @@ static const struct sun4i_i2s_quirks sun8i_h3_i2s_quirks = {
 	.num_bclk_dividers	= ARRAY_SIZE(sun8i_i2s_clk_div),
 	.mclk_dividers		= sun8i_i2s_clk_div,
 	.num_mclk_dividers	= ARRAY_SIZE(sun8i_i2s_clk_div),
-	.get_bclk_parent_rate	= sun8i_i2s_get_bclk_parent_rate,
 	.get_sr			= sun8i_i2s_get_sr_wss,
 	.get_wss		= sun8i_i2s_get_sr_wss,
 	.set_chan_cfg		= sun8i_i2s_set_chan_cfg,
@@ -1518,7 +1413,6 @@ static const struct sun4i_i2s_quirks sun50i_a64_codec_i2s_quirks = {
 	.num_bclk_dividers	= ARRAY_SIZE(sun4i_i2s_bclk_div),
 	.mclk_dividers		= sun4i_i2s_mclk_div,
 	.num_mclk_dividers	= ARRAY_SIZE(sun4i_i2s_mclk_div),
-	.get_bclk_parent_rate	= sun4i_i2s_get_bclk_parent_rate,
 	.get_sr			= sun4i_i2s_get_sr,
 	.get_wss		= sun4i_i2s_get_wss,
 	.set_chan_cfg		= sun4i_i2s_set_chan_cfg,
@@ -1536,7 +1430,6 @@ static const struct sun4i_i2s_quirks sun50i_h6_i2s_quirks = {
 	.num_bclk_dividers	= ARRAY_SIZE(sun8i_i2s_clk_div),
 	.mclk_dividers		= sun8i_i2s_clk_div,
 	.num_mclk_dividers	= ARRAY_SIZE(sun8i_i2s_clk_div),
-	.get_bclk_parent_rate	= sun8i_i2s_get_bclk_parent_rate,
 	.get_sr			= sun8i_i2s_get_sr_wss,
 	.get_wss		= sun8i_i2s_get_sr_wss,
 	.set_chan_cfg		= sun50i_h6_i2s_set_chan_cfg,
@@ -1556,7 +1449,6 @@ static const struct sun4i_i2s_quirks sun50i_r329_i2s_quirks = {
 	.num_bclk_dividers	= ARRAY_SIZE(sun8i_i2s_clk_div),
 	.mclk_dividers		= sun8i_i2s_clk_div,
 	.num_mclk_dividers	= ARRAY_SIZE(sun8i_i2s_clk_div),
-	.get_bclk_parent_rate	= sun8i_i2s_get_bclk_parent_rate,
 	.get_sr			= sun8i_i2s_get_sr_wss,
 	.get_wss		= sun8i_i2s_get_sr_wss,
 	.set_chan_cfg		= sun50i_h6_i2s_set_chan_cfg,
-- 
2.44.0

