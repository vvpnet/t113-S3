diff --git a/aplay/aplay.c b/aplay/aplay.c
index 59f937d..91559cf 100644
--- a/aplay/aplay.c
+++ b/aplay/aplay.c
@@ -142,6 +142,9 @@ static int use_strftime = 0;
 volatile static int recycle_capture_file = 0;
 static long term_c_lflag = -1;
 static int dump_hw_params = 0;
+static unsigned int warm_delay = 0;
+static unsigned int enable_channels[32] =
+{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
 
 static int fd = -1;
 static off64_t pbrec_count = LLONG_MAX, fdcount;
@@ -187,6 +190,25 @@ static const struct fmt_capture {
 	{	begin_au,	end_au,		N_("Sparc Audio"),	LLONG_MAX }
 };
 
+#pragma pack(push, 1)
+struct char24_t
+{
+    //operator char32_t() const { return ( msb << (8*2) ) + ( midb << 8 ) + lsb ; }
+    //uint8_t zero;
+    uint8_t msb;
+    uint8_t midb;
+    uint8_t lsb;
+} uint24_t = {0, 0, 0};
+
+inline void char24_t_set(struct char24_t *dst, u_char* value)
+{
+    dst->lsb = *value & 0xff;
+    uint32_t tmp = *value >> 8;
+    dst->midb = tmp & 0xff;
+    dst->msb = tmp >> 8;
+}
+#pragma pack(pop)
+
 #if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
 #define error(...) do {\
 	fprintf(stderr, "%s: %s:%d: ", command, __func__, __LINE__); \
@@ -234,6 +256,8 @@ _("Usage: %s [OPTION]... [FILE]...\n"
 "-I, --separate-channels one file for each channel\n"
 "-i, --interactive       allow interactive operation from stdin\n"
 "-m, --chmap=ch1,ch2,..  Give the channel map to override or follow\n"
+"-W, --warm-delay=#      The delay in recording the transition process # milliseconds\n"
+"-S, --discard-channels=#Discards preset channels during recording #1101011 (At 0 channel is discarded)\n"
 "    --disable-resample  disable automatic rate resample\n"
 "    --disable-channels  disable automatic channel conversions\n"
 "    --disable-format    disable automatic format conversions\n"
@@ -375,7 +399,7 @@ static void pcm_list(void)
 
 static void version(void)
 {
-	printf("%s: version " SND_UTIL_VERSION_STR " by Jaroslav Kysela <perex@perex.cz>\n", command);
+    printf("%s: version " SND_UTIL_VERSION_STR " by Jaroslav Kysela <perex@perex.cz>, modified by Popov Vladimir <v.v.p.net@mail.ru>\n", command);
 }
 
 /*
@@ -436,6 +460,13 @@ enum {
 	OPT_FATAL_ERRORS,
 };
 
+enum {
+    DISCARD_BITS_8 = 8,
+    DISCARD_BITS_16 = 16,
+    DISCARD_BITS_24 = 24,
+    DISCARD_BITS_32 = 32
+};
+
 /*
  * make sure we write all bytes or return an error
  */
@@ -497,11 +528,154 @@ static long parse_long(const char *str, int *err)
 	return val;
 }
 
+static int enable_channels_parse_string(const char *str)
+{
+    size_t ecs = sizeof(enable_channels);
+    char nstr = str[0];
+    for (size_t i = 0; i < ecs && nstr != '\0'; i++) {
+        if (str[i] == '0' || str[i] == '1') {
+            enable_channels[i] = str[i] - '0';
+            nstr = str[i + 1];
+        } else {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+static inline size_t enable_channels_save_bytes(size_t bits, size_t read)
+{
+    int8_t *out8=(int8_t*)audiobuf;
+    int16_t *out16=(int16_t*)audiobuf;
+    struct char24_t *out24 = (struct char24_t*)audiobuf;
+    int32_t *out32=(int32_t*)audiobuf;
+
+    //size_t cnt = read * hwparams.channels;
+    size_t size = 0;
+    for(size_t i = 0; i < read; i++) {
+        for(unsigned int ch = 0; ch < hwparams.channels; ch++) {
+            if(enable_channels[ch]) {
+                size_t item = i * hwparams.channels + ch;
+                if(bits == DISCARD_BITS_8) {
+                    int8_t tmp8 = out8[item];
+                    out8[size++] = tmp8;
+                } else if(bits == DISCARD_BITS_16) {
+                    int16_t tmp16 = out16[item];
+                    out16[size++] = tmp16;
+                } else if(bits == DISCARD_BITS_24) {
+                    uint24_t = out24[item];
+                    out24[size++] = uint24_t;
+                } else if(bits == DISCARD_BITS_32) {
+                    int32_t tmp32 = out32[item];
+                    out32[size++] = tmp32;
+                }
+            }
+        }
+    }
+
+    size_t count = 0;
+    if(bits == DISCARD_BITS_8)
+        count = (size * sizeof(int8_t));
+    if(bits == DISCARD_BITS_16)
+        count = (size * sizeof(int16_t));
+    if(bits == DISCARD_BITS_24)
+        count = (size * sizeof(uint24_t));
+    if(bits == DISCARD_BITS_32)
+        count = (size * sizeof(int32_t));
+
+    //fprintf(stderr, "read = %zu, count = %zu, size = %zu\n", read, count, size);
+    return count;
+}
+
+static int enable_channels_is_set(unsigned int num_channels)
+{
+    if(num_channels > sizeof (enable_channels))
+        return 0;
+
+    for (unsigned int i = 0; i < num_channels; i++) {
+        if(enable_channels[i] == 0)
+            return 1;
+    }
+    return 0;
+}
+
+static int enable_channels_get_count(unsigned int num_channels)
+{
+    if(!enable_channels_is_set(num_channels))
+        return num_channels;
+
+    if(num_channels > sizeof (enable_channels))
+        return 0;
+
+    int count = 0;
+    for (unsigned int i = 0; i < num_channels; i++) {
+        if(enable_channels[i] > 0)
+            count++;
+    }
+    return count;
+}
+
+static size_t enable_channels_bitrate_detection() {
+    size_t bits = DISCARD_BITS_8;
+    switch ((unsigned long) hwparams.format) {
+    case SND_PCM_FORMAT_U8:
+        bits = DISCARD_BITS_8;
+        break;
+    case SND_PCM_FORMAT_S16_LE:
+    case SND_PCM_FORMAT_U16_LE:
+        bits = DISCARD_BITS_16;
+        break;
+    case SND_PCM_FORMAT_S32_LE:
+    case SND_PCM_FORMAT_FLOAT_LE:
+        bits = DISCARD_BITS_32;
+        break;
+    case SND_PCM_FORMAT_S24_LE:
+    case SND_PCM_FORMAT_S24_3LE:
+    case SND_PCM_FORMAT_U24_LE:
+    case SND_PCM_FORMAT_U24_3LE:
+        bits = DISCARD_BITS_24;
+        break;
+    default:
+        error(_("Doesn't support [discard-channels] %s format..."), snd_pcm_format_name(hwparams.format));
+        prg_exit(EXIT_FAILURE);
+    }
+    return bits;
+}
+
+static unsigned int wdelay_detection(){
+    //unsigned int wdelay = (double)hwparams.rate * warm_delay * hwparams.channels / 1000;
+    unsigned int wdelay = (double)hwparams.rate * warm_delay / 1000;
+//    switch ((unsigned long) hwparams.format) {
+//        case SND_PCM_FORMAT_U8:
+//            wdelay *= 1;
+//            break;
+//        case SND_PCM_FORMAT_S16_LE:
+//        case SND_PCM_FORMAT_S16_BE:
+//        case SND_PCM_FORMAT_U16_LE:
+//        case SND_PCM_FORMAT_U16_BE:
+//            wdelay *= 2;
+//            break;
+//        case SND_PCM_FORMAT_S24_LE:
+//        case SND_PCM_FORMAT_S24_3LE:
+//        case SND_PCM_FORMAT_S24_BE:
+//        case SND_PCM_FORMAT_S24_3BE:
+//        case SND_PCM_FORMAT_U24_LE:
+//        case SND_PCM_FORMAT_U24_3LE:
+//        case SND_PCM_FORMAT_U24_BE:
+//        case SND_PCM_FORMAT_U24_3BE:
+//            wdelay *= 3;
+//            break;
+//        default:
+//            wdelay *= 4;
+//        }
+    return wdelay;
+}
+
 int main(int argc, char *argv[])
 {
 	int duration_or_sample = 0;
 	int option_index;
-	static const char short_options[] = "hnlLD:qt:c:f:r:d:s:MNF:A:R:T:B:vV:IPCi"
+    static const char short_options[] = "hnlLD:qt:c:f:r:d:s:MNF:A:R:T:B:vV:W:S:IPCi"
 #ifdef CONFIG_SUPPORT_CHMAP
 		"m:"
 #endif
@@ -550,6 +724,8 @@ int main(int argc, char *argv[])
 #ifdef CONFIG_SUPPORT_CHMAP
 		{"chmap", 1, 0, 'm'},
 #endif
+        {"warm-delay", 1, 0, 'W'},
+        {"disable-channels", 0, 0, 'S'},
 		{0, 0, 0, 0}
 	};
 	char *pcm_name = "default";
@@ -572,16 +748,16 @@ int main(int argc, char *argv[])
 	assert(err >= 0);
 
 	command = argv[0];
+    //printf("Force switched to arecord mode\n");
+    command = "arecord";
 	file_type = FORMAT_DEFAULT;
-	if (strstr(argv[0], "arecord")) {
+    if (strstr(command, "arecord")) {
 		stream = SND_PCM_STREAM_CAPTURE;
 		file_type = FORMAT_WAVE;
-		command = "arecord";
 		start_delay = 1;
 		direction = stdout;
-	} else if (strstr(argv[0], "aplay")) {
+    } else if (strstr(command, "aplay")) {
 		stream = SND_PCM_STREAM_PLAYBACK;
-		command = "aplay";
 		direction = stdin;
 	} else {
 		error(_("command should be named either arecord or aplay"));
@@ -843,11 +1019,29 @@ int main(int argc, char *argv[])
 			}
 			break;
 #endif
-		default:
-			fprintf(stderr, _("Try `%s --help' for more information.\n"), command);
-			return 1;
-		}
-	}
+        case 'W':
+            warm_delay = parse_long(optarg, &err);
+            if (err < 0) {
+                error(_("invalid warm delay space argument '%s'"), optarg);
+                return 1;
+            }
+            break;
+        case 'S': {
+            int ret = enable_channels_parse_string(optarg);
+            if(ret != 0) {
+                if(ret < 0)
+                    error(_("Number of set channels exceeds the allowed value: %d"), sizeof(enable_channels));
+                if(ret > 0)
+                    error(_("invalid argument does not match the mask 011..111 != '%s'"), optarg);
+                return 1;
+            }
+        }
+            break;
+        default:
+                fprintf(stderr, _("Try `%s --help' for more information.\n"), command);
+                return 1;
+            }
+        }
 
 	if (do_device_list) {
 		if (do_pcm_list) pcm_list();
@@ -2739,7 +2933,8 @@ static void begin_wave(int fd, size_t cnt)
                 f.format = LE_SHORT(WAV_FMT_IEEE_FLOAT);
         else
                 f.format = LE_SHORT(WAV_FMT_PCM);
-	f.channels = LE_SHORT(hwparams.channels);
+
+    f.channels = LE_SHORT(enable_channels_get_count(hwparams.channels));
 	f.sample_fq = LE_INT(hwparams.rate);
 #if 0
 	tmp2 = (samplesize == 8) ? 1 : 2;
@@ -2788,7 +2983,7 @@ static void begin_au(int fd, size_t cnt)
 		prg_exit(EXIT_FAILURE);
 	}
 	ah.sample_rate = BE_INT(hwparams.rate);
-	ah.channels = BE_INT(hwparams.channels);
+    ah.channels = BE_INT(enable_channels_get_count(hwparams.channels));
 	if (xwrite(fd, &ah, sizeof(AuHeader)) != sizeof(AuHeader)) {
 		error(_("write error"));
 		prg_exit(EXIT_FAILURE);
@@ -3284,7 +3479,14 @@ static void capture(char *orig_name)
 	}
 	init_stdin();
 
-	do {
+    unsigned int wdelay = wdelay_detection();
+
+    size_t bits = DISCARD_BITS_8;
+    int is_set_discard_channels = enable_channels_is_set(hwparams.channels);
+    if(is_set_discard_channels)
+        bits = enable_channels_bitrate_detection();
+
+    do {
 		/* open a file to write */
 		if (!tostdout) {
 			/* upon the second file we start the numbering scheme */
@@ -3320,24 +3522,37 @@ static void capture(char *orig_name)
 
 		/* capture */
 		fdcount = 0;
-		while (rest > 0 && recycle_capture_file == 0 && !in_aborting) {
-			size_t c = (rest <= (off64_t)chunk_bytes) ?
+
+        while (rest > 0 && recycle_capture_file == 0 && !in_aborting) {
+            size_t c = (rest <= (off64_t)chunk_bytes) ?
 				(size_t)rest : chunk_bytes;
 			size_t f = c * 8 / bits_per_frame;
 			size_t read = pcm_read(audiobuf, f);
-			size_t save;
-			if (read != f)
-				in_aborting = 1;
-			save = read * bits_per_frame / 8;
-			if (xwrite(fd, audiobuf, save) != save) {
-				perror(name);
-				in_aborting = 1;
-				break;
-			}
-			count -= c;
-			rest -= c;
-			fdcount += save;
-		}
+
+            size_t save_bytes = (f < read ? f : read) * bits_per_frame / 8;
+
+            if(is_set_discard_channels)
+                save_bytes = enable_channels_save_bytes(bits, f < read ? f : read);
+
+            if (read != f)
+                in_aborting = 2;
+
+            //fprintf(stderr, "read = %zu, c = %zu, f = %zu, save_size = %zu bits_per_frame = %zu, rest = %lld, \n", read, c, f, save_bytes, bits_per_frame, rest);
+
+            if(wdelay == 0) {
+                if (xwrite(fd, audiobuf, save_bytes) != save_bytes) {
+                    perror(name);
+                    in_aborting = 1;
+                    break;
+                }
+                count -= c;
+                rest -= c;
+                fdcount += save_bytes;
+            } else if(read > wdelay)
+                wdelay = 0;
+            else
+                wdelay -= read;
+        }
 
 		/* re-enable SIGUSR1 signal */
 		if (recycle_capture_file) {
@@ -3353,9 +3568,13 @@ static void capture(char *orig_name)
 			fd = -1;
 		}
 
-		if (in_aborting)
-			prg_exit(EXIT_FAILURE);
-
+        if (in_aborting) {
+            if(in_aborting == 1) {
+                prg_exit(EXIT_FAILURE);
+            } else {
+                break;
+            }
+        }
 		/* repeat the loop when format is raw without timelimit or
 		 * requested counts of data are recorded
 		 */
